Lambda functions allows you to set up anonymous functions. They can then be assigned to names or called directly.
```C++
// This is the structure
// [capture list](parameters) -> return type {
// 	Function body
// };

// Basic Example
[]() {
	std::cout << "HELLO FROM LAMBDA!!!" << std::endl;
};

// Can also assign it to a variable and then call it
auto func = []() {
	std::cout << "Hello again" << std::cout;
};
func();

// You can also define and then immediately call it
[]() {
	std::cout << "Hello again" << std::cout;
}(); // Call directly with ()

// Pass parameters and then call immediatley with parameters
[](int a, int b) {
	std::cout << "Sum: " << a + b << std::cout;
}(1,2);

// Call function and store it's results
auto result = [](int a, int b) {
	return (a + b);
}(1,2);

// Explicitly define return time
auto result = [](int a, int b) -> int {
	return (a + b);
}(1,2);
```

## Capture List
The body of a lambda function has it's own isolated scope. This means if you want to include data in the scope of a lambda function, you have to use the capture list to pass it through.
```C++
double a{10};
double b{20};

auto func = [a,b]() {
	std::cout << "Result: " << a + b << std::endl
};
func();
```

When you pass data in a capture list, you create a copy of it and store it in the capture list. This means you if you update it externally, the copy in the capture list does not change.
```C++
#include <iostream>

int main() {
    int c{42};

    auto func = [c](){
        std::cout << "Inner Value: " << c << std::endl;
    };

    for (size_t i{}; i < 5; i++) {
        std::cout << "Outer Value: " << c << std::endl;
        func();
        ++c;
    }
}
```

The Output of the above is:
```Bash
Outer Value: 42
Inner Value: 42
Outer Value: 43
Inner Value: 42
Outer Value: 44
Inner Value: 42
Outer Value: 45
Inner Value: 42
Outer Value: 46
Inner Value: 42
```

Capture lists are really good for capturing state while variables are good for input that is changing.

## Capturing Everything in the Context
If you pass an '=' in the capture list, you capture the entire context.
```C++
int c{42};
int d{43};

auto func = [=](){
	std::cout << "Summed Value: " << c + d << std::endl;
};
```