This is just a section that covers some random odds and ends to do with Functions.

## Static Variables
Static variables are variables that exist throughout the entire lifetime of your application in its same scope. In the below example, the output is 1,2,3,4,5 as the instance of the integer sum is static. This means that every time the function is called, it increments the same variable in memory.
```C++
int temp() {
    static int sum{0};
    return ++sum;
}

int main() {

    for (size_t i{}; i < 5; i++) {
        // sum++; This would cause an error because it is out of scope
        std::cout << temp() << std::endl;
    }
}
```

## Inline Functions
You can add inline to a function to try and make the compiler evaluate it in place whenever it is called. This is useful as you avoid the overhead of a function call overhead. It does have the downside of potentially increasing the size of you application binary. Ideal for short, frequently used functions. Ultimately, it is up to your compiler whether it chooses to inline or ignore.
```C++
inline int max(int a, int b) {
	if (a > b) {
		return a;
	} else {
		return b;
	}
}

int main() {
	int a{2};
	int b{5};
	
	max(a, b); // The compiler will try to copy the code of the function in place
			   // to avoid the overhead of a function call.
	
	return 0;
}
```