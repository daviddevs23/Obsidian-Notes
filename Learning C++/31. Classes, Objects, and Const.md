When you create an instance of a class with the const keyword, you will be locked out of it. You won't be able to modify or read from them at all.

```C++
const Dog dog1("Fido", "Shepherd", 3);
```

In order to get around this, we need to tell the compiler that some member functions will never modify the object. That way when we create a const instance of an object, we can still read the data while maintaining the lock that prevents the object from being modified. You can do this by appending the const keyword to a member function that does not modify the object.
```C++
std::string getName() const { // Append const
	return dogName;
}

std::string getBreed() const { // Append const
	return dogBreed;
}
```

Now I can use these functions, even if the instance of the object is marked as static.

You can also overload functions based on whether the object is const or not. This works because by adding the const keyword after the function, you are guaranteeing that you will not modify the state of the object.
```C++
// Called when const
std::string getBreed() const { // Append const
	return dogBreed;
}

// Called when not const, can modify data
std::string getBreed() {
	printCount++;
	return dogBreed;
}
```

## Dangling References/Pointers
In the following example, we create a local variable and return a pointer/reference to it. The problem is that that variable is destroyed when you return from the function, causing the resulting pointer or reference to point to garbage.
```C++
double& x()  {
	double local_var{m_x};
	return local_var;
}
```

## Mutable Keyword
Let's say you have a const function in a class but you want to change a value for debug purposes, the following example shows you how to do do this for debug purposes.

```C++
class Dog
{
public:
    Dog();
	
    void print_info() const{
        ++info_print_count;
        std::cout << "Dog name : " << dog_name <<
            ", dog breed : " << dog_breed <<
            ", dog age : " << *dog_age
            << "print_count : " << info_print_count << std::endl;
    }
	
private:
    std::string dog_name;
    std::string dog_breed;
    int * dog_age;
	
	// Mutable Keyword allows this to be changed, even when const
    mutable size_t info_print_count{0};
};
```

